# 機能仕様: Cellactor Actor Core 初期実装

**ブランチ**: `[002-init-actor-lib]`  
**作成日**: 2025-10-28  
**ステータス**: Draft  
**入力**: ユーザ要望: "docs/spec.mdを基にRust版のアクターライブラリの初期実装を作る\n\n- Untyped, Handleというキーワードが入ってるかも。制約違反かも。いずれにしても制約のほうが強いです。適切にしてほしい。\n- ActorErrorは構造体で固定になるかしら。Box<dyn ActorError>的なものがよいかしら。"

> 原則3遵守のため、protoactor-go / Apache Pekko の該当箇所調査と Rust への落とし込み方針を各節で明示すること。

## ユーザーストーリーとテスト（必須）

ユーザーストーリーは優先度付きの独立したユーザージャーニーとして記述し、単体で価値を届けられることを保証する。  
各ストーリーでは、protoactor-go と Apache Pekko で確立された振る舞いと整合しつつ、命名規約と no_std 制約に合わせた Rust での再設計方針を明記する。

### ユーザーストーリー1 - システム内で安全にアクターを起動したい（優先度: P1）

セルアクター利用開発者として、Apache Pekko Typed の `ActorSystem` / `Behaviors.setup` と protoactor-go の `RootContext` で得られる起動体験を Rust でも再現し、アクター参照がシステムスコープから漏れない安全な実行環境を得たい。

**優先度の理由**: アクターシステム起動が成立しなければ他機能を検証できず、初期リリース価値が失われるため。  
**独立テスト**: ドキュメントサンプル通りに `ActorSystem` を初期化し、スコープ内でカウンタアクターをスポーンしてメッセージを往復させる統合テストを実行。システム外へ参照を持ち出そうとした場合に拒否されることを確認する。

**受け入れシナリオ**:

1. **前提** ActorSystem がデフォルト設定で起動済み、Props による振る舞いが登録されている。**操作** システムスコープ内からアクターを生成し 1 件のメッセージを送信。**結果** メッセージが一度だけ処理され、結果がスコープ内で観測できる。
2. **前提** 上記で取得したアクター参照をスコープ外へ返却するコードパスを用意。**操作** 参照経由でメッセージ送信を試行。**結果** コンパイルもしくは実行時チェックで拒否され、ログに設計方針（スコープ外公開禁止）が記録される。

### ユーザーストーリー2 - メールボックスで負荷を制御したい（優先度: P1）

セルアクター運用者として、protoactor-go の Bounded/Unbounded mailbox と Dispatcher の挙動を Rust でも選択でき、Apache Pekko の Mailbox 設定と同等のバックプレッシャー制御を no_std 環境でも使いたい。

**優先度の理由**: メッセージ詰まりは全システムの信頼性に直結し、初期段階での安定動作を左右するため。  
**独立テスト**: 容量 10 のメールボックスに 11 件送信して保留通知を確認するテスト、および複数アクターでスケジューラ順序が維持されることを検証する負荷テストを実施。

**受け入れシナリオ**:

1. **前提** 容量 10 のメールボックスを Props で指定。**操作** 11 件のメッセージを連続送信。**結果** 11 件目が保留または明示的エラーとして報告され、先行分の順序が保持される。
2. **前提** デフォルト Dispatcher を共有する 3 つのアクターが存在。**操作** Round-Robin でメッセージを投入。**結果** ログまたはメトリクスで公平な割当が確認でき、優先度チェンジなどの逸脱が発生しない。

### ユーザーストーリー3 - 失敗時の回復方針を制御したい（優先度: P1）

セルアクター運用者として、Apache Pekko Typed の Supervision 戦略や protoactor-go の `SupervisorStrategy` で得られる再起動・停止制御を Rust で再利用し、アクター失敗時の影響範囲を短時間で限定したい。

**優先度の理由**: エラー復旧が不透明だと運用導入が不可能になり、初期パイロットの採用判断が下せないため。  
**独立テスト**: フェイルする子アクターを用意し、OneForOne/AllForOne の両戦略で再起動・停止判断が仕様通り行われることを検証するシナリオテストを実施。

**受け入れシナリオ**:

1. **前提** OneForOne + 再起動上限 3 回/60 秒の設定が有効。**操作** 子アクターに連続して回復可能エラーを発生させる。**結果** 3 回まで再起動し、4 回目で停止イベントが親に通知される。
2. **前提** Stop 戦略が設定されている。**操作** 子アクターが致命的エラー分類を返すメッセージを受信。**結果** 子アクターが停止し、監視者に原因と分類が共有される。

### 境界条件・例外

- System スコープ外からのアクター参照操作は拒否される。不可視化できないケースでは監査ログと共にフェイルファストする。
- メールボックスが許容量を超えた場合は、保留・ドロップ・抑止等のポリシーごとに通知が必須であり、暗黙のドロップは禁止する。
- Supervision 戦略未設定時は安全デフォルトとして停止を選択し、protoactor-go との互換性よりも Rust 実装の明瞭さを優先する。

## 要件（必須）

機能要件はテスト可能な文として記述し、`no_std` 制約や破壊的変更の扱いを明確にする。  
各要件では参照元（protoactor-go, Apache Pekko）と差分方針を併記する。

### 機能要件

- **FR-001**: ActorSystem はシステム内専用の実行スコープを提供し、アクター参照を外部へムーブできないようにしなければならない（Pekko `ActorSystem` のスコープ設計に倣い、protoactor-go `RootContext` との違いを仕様に残す）。
- **FR-002**: Props/Behavior ビルダは初期状態の注入・ライフサイクルフック・監視設定をチェーン設定できること（protoactor-go `Props` と Pekko `Behavior` API の共通機能を網羅し、`Handle` といった命名は使用しない）。
- **FR-003**: メールボックスはバウンデッド/アンバウンデッドを選択可能とし、オーバーフローポリシー（保留・最新破棄・最古破棄・拡張）を構成できなければならない。挙動は protoactor-go `mailbox` 実装と一致し、no_std 環境で利用できるメモリ戦略を明示する。
- **FR-004**: Dispatcher は公平性メトリクスを公開し、複数アクター間でのスケジュール順序が Pekko の Mailbox/Dispatcher 契約と整合することを検証可能にしなければならない。
- **FR-005**: コア機能は `#![no_std]` 環境で動作し、`std` 依存は `cfg(test)` または `modules/*-std` に隔離しなければならない。共有参照は `modules/utils-core` の抽象を利用し、直接的な `Arc` や OS 依存ロックへの依存を避ける。
- **FR-006**: ActorError 相当のエラー分類は再試行ポリシー・重篤度・時間窓を保持する拡張可能なデータモデルとして提供され、アプリケーションが列挙拡張またはトレイト実装で独自分類を追加できなければならない（protoactor-go `actor/errors.go` と Pekko `SupervisorStrategy` の分類方針を統合）。
- **FR-007**: Supervision 戦略は Restart/Stop/Resume/Escalate を備え、条件分岐を利用者が登録できる判定器として公開しなければならない。判定器の名前には `Untyped` を含めず、Rust の列挙型とクロージャで表現する方針を仕様化する。
- **FR-008**: メッセージアダプタ層は型安全な変換 API を提供し、内部での動的ディスパッチは必要最小限に留める。命名には歴史的な `UntypedEnvelope` を用いず、新しい名称（例: `ErasedMessageEnvelope`）を仕様で提示する。
- **FR-009**: イベントストリームは購読・解除・バックプレッシャーヒントを提供し、観測指標をテストで検証できる形式で公開しなければならない（protoactor-go `eventstream` と Pekko `EventStream` の差異を記述）。
- **FR-010**: 仕様で定義する公開 API はバイナリ互換ではなくソース互換を前提とし、破壊的変更を許容する代わりに変更理由と移行方針を spec/plan/tasks に記録する。

### 重要エンティティ（データを扱う場合）

- **ActorSystemScope**: システム初期化時に生成される実行スコープ。アクター生成、参照管理、監査ログ出力を担い、外部公開を禁止する境界。
- **BehaviorProfile**: Props/Behavior ビルダで確定する振る舞い設定。状態初期化、メールボックス種別、監視ポリシー、計測設定などを束ねる。
- **MessageQueuePolicy**: メールボックスの容量・優先度・バックプレッシャーポリシーを記述する設定。テストで検証可能な閾値と通知内容を保持する。
- **RecoveryPolicy**: Supervision の戦略と ActorError 分類を関連付けるデータ。再試行回数、時間窓、重篤度などのパラメータを含む。
- **ObservationChannel**: イベントストリームおよび Dispatcher メトリクスを購読するための抽象化。遅延やドロップなどの指標を外部へ伝播する。

## 成功指標（必須）

技術に依存しない測定可能な指標を設定する。検証はホスト OS と組込み向けビルド双方で行う。

### 定量的成果

- **SC-001**: 95% のメッセージが送信から 5ms 以内に処理完了し、再試行が不要である（代表的なホスト環境と組込み環境で計測）。
- **SC-002**: 容量 10 のメールボックスで 11 件目投入時に 100% のケースで通知が発生し、既存メッセージの順序破壊が 0 件である。
- **SC-003**: Supervision テストで再起動戦略が期待値どおり遷移し、許容回数を超えた場合に停止イベントが 100% 観測される。
- **SC-004**: 代表的な protoactor-go サンプル（カウンタ）を本仕様の API へ移植する作業時間が従来比 +20% 以内に収まると評価者 3 名以上から確認される。
- **SC-005**: イベントストリームの購読・解除を 1000 回繰り返しても遅延通知や幽霊イベントの発生率が 0% である。

## 前提・仮定

- no_std 対応のため、タイマーやスレッドプールは既存 `modules/*-core` 抽象を必須とし、新規ランタイム依存を追加しない。
- エラー分類は列挙型ベースで提供しつつ、将来の柔軟性確保のためにトレイトを介した拡張ポイントを同時に設ける。
- 命名規約から `Untyped`・`Handle` を排除し、新名称は設計段階でレビュー対象とする。
