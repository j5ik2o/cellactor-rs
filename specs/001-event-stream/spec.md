# 機能仕様: EventStream 実装

**ブランチ**: `001-event-stream`  
**作成日**: 2025-10-28  
**ステータス**: Draft  
**入力**: ユーザ要望: "protoactor-go, pekko/akkaにもあるEventStreamを実装してください。仕様はこれらと同じでＯＫ"

> 原則3遵守のため、protoactor-go `eventstream` パッケージおよび Pekko(Akka) `akka.actor.typed.eventstream` を参照し、Rust actor-core への適用方針を節ごとに明示する。

## ユーザーストーリーとテスト（必須）

### ユーザーストーリー1 - グローバルなイベントバスを利用したい（優先度: P1）

セルアクター利用開発者として、システム全体で共有される EventStream にイベントを publish し、型に基づく購読を行いたい。これによりアクター間の疎結合な通知を容易に実装できる。  
参照: protoactor-go `eventstream/event_stream.go`, Pekko `EventStream`.

**優先度の理由**: コア機能が存在しないと監視・ログ連携・サイドチャネル通知が実現できない。  
**独立テスト**: イベントを publish し、型一致する購読者のみがコールバックを受け取る統合テスト。

**受け入れシナリオ**:

1. **前提** イベント型 `SystemEvent` を購読する actor を登録。**操作** `EventStream.publish(Box::new(SystemEvent::Started))` を呼ぶ。**結果** 登録した購読者のコールバックが 1 回呼び出される。  
2. **前提** 別の actor が `UserEvent` のみ購読。**操作** `SystemEvent` を publish。**結果** `UserEvent` 購読者には通知が届かない。

---

### ユーザーストーリー2 - 一時的な購読と解除を管理したい（優先度: P1）

オペレーション担当者として、イベントを一定期間だけ購読したり、アクター停止時に購読を自動解除したい。これによりリソースリークや不要な通知を防げる。  
参照: protoactor-go `eventstream.Subscription`, Pekko `EventStream.subscribe/unsubscribe`.

**優先度の理由**: 購読解除ができないとシステムが肥大化し、安定運用が難しくなる。  
**独立テスト**: `subscribe` → `unsubscribe` の流れで通知が止まること、アクター停止時に自動解除されることを確認。

**受け入れシナリオ**:

1. **前提** Actor A が購読中。**操作** `unsubscribe(A)` を呼んだ後、イベントを publish。**結果** A のコールバックが呼ばれない。  
2. **前提** Actor B が購読中。**操作** Actor B を停止。**結果** EventStream 内の購読リストから B が削除され、以後通知されない。

---

### ユーザーストーリー3 - メトリクスとバッファリングを制御したい（優先度: P2）

セルアクター SRE として、EventStream の publish/subscribe 数、ドロップイベント数、バックプレッシャー状態を観測し、購読者が遅延した場合に適切にバッファリングやドロップ戦略を適用したい。  
参照: Pekko EventStream の監視 API、protoactor-go のイベント統計。

**優先度の理由**: 本番運用でストリームの遅延が発生した際に原因追跡が困難になるため。  
**独立テスト**: 遅延する購読者をシミュレートし、設定したドロップ戦略・メトリクス記録が期待通りに動作することを確認。

**受け入れシナリオ**:

1. **前提** バッファ容量 10、DropOldest 戦略を設定。**操作** 15 件のイベントを publish、購読者は処理を遅延。**結果** 古い 5 件がドロップされ、ドロップ数メトリクスに反映される。  
2. **前提** メトリクス監視が有効。**操作** 1000 件のイベントを publish。**結果** Throughput と遅延指標が記録され、しきい値超過時にバックプレッシャー警告が生成される。

### 境界条件・例外

- EventStream は `#![no_std]` 環境で動作し、utils-core の queue / Shared 抽象を利用して循環参照を避けた設計を採用する。  
- 購読者が panic した場合、その購読は自動的に解除され、エラーメトリクスとログを記録する。  
- 型マッチングは Rust の `Any` と Downcast を利用するが、ユーザ向け API はジェネリック型で提供し、`Typed` という名称を避ける。  
- バックプレッシャー戦略はメールボックス規約と同様（DropNewest / DropOldest / Grow / Block）を踏襲する。  

## 要件（必須）

### 機能要件

- **FR-001**: システムはグローバルな EventStream を提供し、任意のイベント型を publish できる API (`publish<E: Event>`) を備えなければならない。  
- **FR-002**: EventStream は型に基づく購読（`subscribe<E>`）を提供し、登録した購読者にのみイベントを配送しなければならない。  
- **FR-003**: 購読は明示的解除 (`unsubscribe`) とアクター停止時の自動解除の両方をサポートし、登録数をメトリクスで観測できなければならない。  
- **FR-004**: EventStream の内部キューは utils-core の queue 実装を利用し、メールボックスと同様のオーバーフローポリシー（DropNewest / DropOldest / Grow / Block）を設定できなければならない。  
- **FR-005**: 遅延購読者に対してバックプレッシャーヒントを生成し、必要に応じてイベントをドロップまたは遅延させる仕組みを提供しなければならない。  
- **FR-006**: EventStream 内部では `Any` による型抹消を行うが、公開 API はジェネリック型を維持し `Typed` 命名を使用しない。  
- **FR-007**: イベント publish/ドロップ/購読登録・解除の各操作についてメトリクスとログを記録し、監視システムが利用できるようにしなければならない。  
- **FR-008**: EventStream は循環参照を避けた設計（例: 関数型コールバック、弱参照を多用しない構造）を採用し、`Shared` 命名規約と使用最小化方針を遵守しなければならない。  
- **FR-009**: すべての機能は `#![no_std]` 環境で動作し、`std` 依存は `actor-std` 拡張でのみ提供する。  

### 重要エンティティ

- **EventStream**: イベントの publish/subscribe を管理するシングルトン。  
- **Subscription**: 購読者のハンドラとメタ情報（優先度、バッファ設定）を保持する構造体。  
- **EventBuffer**: utils-core queue をラップしてイベントを一時保管するバッファ。  
- **EventMetrics**: publish 数、ドロップ数、購読者数、遅延指標を収集する観測エンティティ。  
- **BackpressureHint**: 遅延購読者が発生した際に発行されるシグナル。  

## 成功指標（必須）

### 定量的成果

- **SC-001**: 1000 件/秒のイベント publish 時に遅延なく購読者へ配送でき、平均遅延が 5ms 以下であること。  
- **SC-002**: 購読解除後にイベントが配送されるケースが 0 件であること。  
- **SC-003**: バッファ容量を超えた際に設定したドロップ戦略が 100% 適用され、ドロップ数メトリクスに反映されること。  
- **SC-004**: EventStream によるバイナリサイズ増加が 5% 未満、ランタイムメモリ増加が 10% 未満に収まること（標準ベンチマーク）。  

## 前提・制約

- EventStream は actor-core に実装し、`actor-std` では標準ライブラリ連携（ログ出力等）を追加できる拡張ポイントを用意する。  
- イベント型は `Send + 'static` を満たす必要があり、非同期処理は購読者側で扱う。  
- バックプレッシャーの詳細動作はメールボックス仕様と統一し、既存のテストユーティリティを再利用する。  
- 外部システム（HTTP、gRPC 等）との連携は本仕様のスコープ外。  

## 非目標

- 分散クラスタ間での EventStream レプリケーション。  
- Durable なイベントストレージ（イベントソーシング機能）。  
- イベント型の自動スキーマ生成やリフレクションベースの検証。  
