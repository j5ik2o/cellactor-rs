//! Backend that completes ask-style futures upon receiving responses.

use cellactor_utils_core_rs::ArcShared;

use crate::{
  actor_future::{ActorFuture, ActorFutureError},
  actor_ref_backend::ActorRefBackend,
  any_message::AnyOwnedMessage,
  send_error::SendError,
};

/// Backend used for the temporary `reply_to` handle generated by
/// [`ActorRef::ask`](crate::ActorRef::ask).
pub(crate) struct AskReplyEndpoint {
  future: ArcShared<ActorFuture<AnyOwnedMessage>>,
}

impl AskReplyEndpoint {
  /// Creates a new endpoint bound to the provided future.
  pub(crate) fn new(future: ArcShared<ActorFuture<AnyOwnedMessage>>) -> Self {
    Self { future }
  }
}

impl ActorRefBackend for AskReplyEndpoint {
  fn send(&self, message: AnyOwnedMessage) -> Result<(), SendError> {
    let attempt = message.clone();
    match self.future.complete(attempt) {
      | Ok(()) => Ok(()),
      | Err(ActorFutureError::AlreadyCompleted) => {
        Err(SendError::already_responded(message, Some("future already completed".into())))
      },
      | Err(ActorFutureError::CallbackAlreadyRegistered) => {
        Err(SendError::already_responded(message, Some("callback already registered".into())))
      },
    }
  }
}
